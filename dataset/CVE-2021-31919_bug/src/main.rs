// main.rs

use std::mem;

#[derive(Debug)]
struct MyStruct {
    field: u32,
}

impl MyStruct {
    fn new() -> Self {
        MyStruct { field: 42 }
    }

    fn resolve_unsized(&self, ptr: *mut mem::MaybeUninit<MyStruct>) {
        unsafe {
            // Simulate uninitialized memory and writing zero bytes to it.
            let mut resolved = mem::MaybeUninit::<MyStruct>::uninit();
            resolved.as_mut_ptr().write_bytes(0, 1);

            ptr.write(resolved.assume_init());
        }
    }
}

fn main() {
    unsafe {
        // Allocate space for an uninitialized MyStruct
        let raw: *mut mem::MaybeUninit<MyStruct> = Box::into_raw(Box::new(mem::MaybeUninit::<MyStruct>::uninit()));

        // Create a new struct instance.
        let my_struct = MyStruct::new();

        // Resolve the unsized pointer using a mock function that writes zero bytes to it.
        my_struct.resolve_unsized(raw);

        // Dereference and print the resolved value, which should be initialized with zeros now.
        println!("{:?}", (*raw).assume_init());

        // Clean up memory
        Box::from_raw(raw);
    }
}
