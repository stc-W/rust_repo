// main.rs

#![forbid(unsafe_code)]

use crossbeam_utils::thread;
use std::cell::Cell;

#[derive(Debug)]
enum RefOrInt<'a> {
    Ref(&'a u64),
    Int(u64),
}

struct Cow<'a, T: ?Sized + 'a, U = ()> where
    T: Beef,
    U: Capacity,
{
    // This is a simplified version of the Cow struct.
    // In reality, it has more fields and methods to handle different states (owned/borrowed).
    borrowed: Option<&'a T>,
}

impl<'a, T: ?Sized + 'a, U> Cow<'a, T, U>
where
    T: Beef,
    U: Capacity,
{
    fn borrowed(b: &'a T) -> Self {
        Cow { borrowed: Some(b) }
    }

    fn unwrap_borrowed(&self) -> &'a T {
        self.borrowed.unwrap()
    }
}

trait Beef {}
impl<T> Beef for [T] {}

trait Capacity {}

// Example static integer
static SOME_INT: u64 = 123;

fn main() {
    let x = [Cell::new(RefOrInt::Ref(&SOME_INT))];

    thread::scope(|s| {
        let cow1: Cow<[Cell<RefOrInt>]> = Cow::borrowed(&x[..]);
        let cow2: Cow<[Cell<RefOrInt>]> = Cow { borrowed: cow1.borrowed };

        let child = s.spawn(move |_| {
            // We've now smuggled the cell from above into this thread.
            let smuggled_cell = cow2.unwrap_borrowed();
            loop {
                // Repeatedly write Ref(&addr) and Int(0xdeadbeef) into the cell.
                smuggled_cell[0].set(RefOrInt::Ref(&SOME_INT));
                smuggled_cell[0].set(RefOrInt::Int(0xdeadbeef));
            }
        });

        loop {
            let main_thread_cell = cow1.unwrap_borrowed()[0].clone().into_inner();
            if let RefOrInt::Ref(addr) = main_thread_cell {
                // Hope that between the time we pattern match the object as a
                // `Ref`, it gets written to by the other thread.
                if addr as *const u64 == &SOME_INT as *const u64 {
                    continue;
                }

                // Due to the data race, obtaining Ref(0xdeadbeef) is possible
                println!("Pointer is now: {:p}", addr);
                println!("Dereferencing addr will now segfault: {}", *addr);
            }
        }
    });
}
