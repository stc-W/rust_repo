use prost_types::Timestamp;
use std::time::{SystemTime, UNIX_EPOCH};

fn main() {
    // Proof of concept test cases from the issue description
    let timestamp1 = Timestamp { seconds: i64::MAX, nanos: 0 };
    match SystemTime::try_from(timestamp1) {
        Ok(system_time) => println!("Converted to SystemTime without panic: {:?}", system_time),
        Err(e) => eprintln!("Failed to convert: {}", e)
    }

    let timestamp2 = Timestamp { seconds: i64::MAX, nanos: i32::MAX };
    match SystemTime::try_from(timestamp2) {
        Ok(system_time) => println!("Converted to SystemTime without panic: {:?}", system_time),
        Err(e) => eprintln!("Failed to convert: {}", e)
    }
}

// Implement the `TryFrom` conversion for `SystemTime`
impl TryFrom<Timestamp> for SystemTime {
    type Error = TimestampOutOfSystemRangeError;

    fn try_from(mut timestamp: Timestamp) -> Result<Self, Self::Error> {
        let orig_timestamp = timestamp.clone();

        // Normalize the timestamp
        timestamp.normalize();

        // Attempt to convert from `Timestamp` to `SystemTime`
        let system_time = UNIX_EPOCH.checked_add(std::time::Duration::from_secs(timestamp.seconds as u64))
            .and_then(|t| t.checked_sub(std::time::Duration::from_nanos((-timestamp.nanos) as u64)));

        // Return the result of conversion
        system_time.ok_or(TimestampOutOfSystemRangeError {
            timestamp: orig_timestamp,
        })
    }
}

#[derive(Debug)]
struct TimestampOutOfSystemRangeError {
    pub timestamp: Timestamp,
}

impl std::fmt::Display for TimestampOutOfSystemRangeError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(
            f,
            "{:?} is not representable as a `SystemTime` because it is out of range",
            self
        )
    }
}

impl std::error::Error for TimestampOutOfSystemRangeError {}

// Placeholder for normalize method (should be implemented based on the crate's actual logic)
impl Timestamp {
    fn normalize(&mut self) {
        // The implementation should prevent overflow and panic as per the fix mentioned in the issue description
        // Here, we assume it handles the normalization correctly to avoid panics.
    }
}
