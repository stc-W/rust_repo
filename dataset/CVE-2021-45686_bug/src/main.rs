//! UB demo for csv-sniffer issue #1 that (1) runs fast in Miri
//! and (2) still shows the wrong behaviour with plain `cargo run`.

use csv_sniffer::{Sniffer, error::SnifferError};
use std::io::{self, Read, Seek, SeekFrom};

/* ---------- configurable poison size ---------- */
const POISON_ITERS: usize = if cfg!(miri) { 200 } else { 20_000 };
const CHUNK: usize = 1 << 12; // 4 KiB – same as preamble_skipcount

/* ---------- Evil reader ---------- */
struct EvilReader { data: &'static [u8], pos: usize }

impl Read for EvilReader {
    fn read(&mut self, buf: &mut [u8]) -> io::Result<usize> {
        println!("EvilReader saw first byte = {}", buf[0]); // UB if buf uninit
        let remain = &self.data[self.pos..];
        let n = remain.len().min(buf.len());
        buf[..n].copy_from_slice(&remain[..n]);
        self.pos += n;
        Ok(n)
    }
}

impl Seek for EvilReader {
    fn seek(&mut self, pos: SeekFrom) -> io::Result<u64> {
        self.pos = match pos {
            SeekFrom::Start(o)   => o as usize,
            SeekFrom::Current(o) => (self.pos as i64 + o) as usize,
            SeekFrom::End(o)     => (self.data.len() as i64 + o) as usize,
        };
        Ok(self.pos as u64)
    }
}

fn main() -> Result<(), SnifferError> {
    /* 1 ── fill the allocator’s free-list with non-zero bytes */
    for _ in 0..POISON_ITERS {
        let v = vec![0xAAu8; CHUNK];
        std::hint::black_box(v);
    }

    /* 2 ── tiny CSV input */
    static CSV: &str = "skip\nheader1,header2\n1,2\n";
    let mut evil = EvilReader { data: CSV.as_bytes(), pos: 0 };

    /* 3 ── trigger csv-sniffer’s preamble_skipcount */
    let meta = Sniffer::new().sniff_reader(&mut evil)?;
    println!("Sniffer done; delimiter '{}'", meta.dialect.delimiter as char);
    Ok(())
}
