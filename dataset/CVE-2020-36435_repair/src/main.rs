#![forbid(unsafe_code)]

// Assuming ruspiro-singleton crate is already included in Cargo.toml
use ruspiro_singleton::Singleton;

use std::{cell::Cell, thread};

#[derive(Debug, Clone, Copy)]
enum RefOrInt<'a> { Ref(&'a u64), Int(u64) }

static SOME_INT: u64 = 123;

// Static singleton with Cell to demonstrate the issue
static STATIC_CELL : Singleton<Cell<RefOrInt>> = Singleton::lazy(|| {
    Cell::new(RefOrInt::Ref(&SOME_INT))
});

fn main() {
    // Spawn a thread that continuously updates the cell's content.
    let handle = thread::spawn(move || loop {
        STATIC_CELL.with_ref(|cell| {
            cell.set(RefOrInt::Ref(&SOME_INT));
            cell.set(RefOrInt::Int(0xdeadbeef));
        });
    });

    // Main thread continuously checks the cell's content.
    loop {
        STATIC_CELL.with_ref(|cell| {
            if let RefOrInt::Ref(addr) = cell.get() {
                if addr as *const u64 == &SOME_INT as *const u64 { continue; }

                // If the main thread reads a `Ref(0xdeadbeef)` from another thread,
                // it will lead to undefined behavior when dereferencing.
                println!("Pointer is now: {:p}", addr);
                println!("Dereferencing addr will cause an error: {}", *addr);
            }
        });
    }

    // The main thread never reaches here; the spawned thread runs concurrently.
    handle.join().unwrap();
}
