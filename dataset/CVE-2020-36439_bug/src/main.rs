#![forbid(unsafe_code)]

use futures::Future;
use std::{rc::Rc, thread};

#[derive(Debug)]
struct TicketedLock<T> {
    value: T,
}

impl<T> TicketedLock<T> {
    fn new(value: T) -> Self {
        TicketedLock { value }
    }

    fn read(&mut self) -> ReadTicket<&T> {
        ReadTicket(self.value.as_ref())
    }
}

struct ReadTicket<'a, T>(&'a T);

impl<'a, T> ReadTicket<'a, T> {
    // Simulating the wait() method. In reality, it might involve more complex logic.
    fn wait(self) -> Result<&'a T, &'static str> {
        Ok(self.0)
    }
}

// The bug arises due to `ReadTicket` implementing `Send` without a `T: Send` bound.
unsafe impl<T> Send for ReadTicket<'_, T> {}

fn main() {
    let rc = Rc::new(());
    let rc_clone = rc.clone();
    
    let mut lock = TicketedLock::new(rc_clone);

    let read_ticket = lock.read();
    thread::spawn(move || {
        // This is where the non-Send type `Rc` gets sent to another thread.
        let smuggled_rc = read_ticket.wait().unwrap();

        println!("Thread: {:p}", *smuggled_rc);
        // Race the refcount with the main thread.
        for _ in 0..100_000_000 {
            Rc::clone(smuggled_rc);
        }
    });

    println!("Main:   {:p}", rc);
    for _ in 0..100_000_000 {
        Rc::clone(&rc);
    }

    // Join the thread to ensure it finishes before the program exits.
    std::thread::sleep(std::time::Duration::from_secs(2));
}
