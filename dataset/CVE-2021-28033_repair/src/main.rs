#![forbid(unsafe_code)]

use std::convert::TryInto;

// Mock ByteStruct and related traits for reproduction.
pub trait ByteStructLen {
    const BYTE_LEN: usize;
}

pub trait ByteStruct {
    fn write_bytes(&self, bytes: &mut [u8]);
    fn read_bytes(bytes: &[u8]) -> Self;
}

impl ByteStructLen for CustomByteStruct {
    const BYTE_LEN: usize = 1;
}

#[derive(Debug)]
struct CustomByteStruct(u8);

impl ByteStruct for CustomByteStruct {
    fn write_bytes(&self, bytes: &mut [u8]) { }
    
    // Simulate a panic to trigger the soundness issue.
    fn read_bytes(_: &[u8]) -> Self {
        panic!("Panic when reading");
    }
}

// Implement Drop trait to observe uninitialized memory on drop.
impl Drop for CustomByteStruct {
    fn drop(&mut self) {
        println!("Dropping {:?}", self.0);
    }
}

#[derive(Debug)]
struct ArrayOfCustomByteStruct {
    custom_structs: [CustomByteStruct; 2],
}

impl ByteStruct for ArrayOfCustomByteStruct {
    fn write_bytes(&self, bytes: &mut [u8]) { }

    // This function would trigger the soundness issue.
    fn read_bytes_default_le(bytes: &[u8]) -> Self {
        let len = <CustomByteStruct as ByteStructLen>::BYTE_LEN;
        
        let custom_structs = (0..2)
            .map(|i| {
                CustomByteStruct::read_bytes(&bytes[i * len .. (i + 1) * len])
            })
            // Collect into a Vec<_> and convert to array using `try_into`.
            .collect::<Vec<CustomByteStruct>>()
            .try_into().unwrap();
        
        ArrayOfCustomByteStruct { custom_structs }
    }
}

fn main() {
    let bytes = [0x01, 0x02];
    
    // Trigger the panic and observe uninitialized memory.
    let _deserialized = ArrayOfCustomByteStruct::read_bytes_default_le(&bytes);
}
