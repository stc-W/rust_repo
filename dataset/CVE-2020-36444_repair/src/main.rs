// main.rs

#![forbid(unsafe_code)]

use std::cell::Cell;
use std::sync::Arc;

// Assuming we need to mock or include ArcGuard and its implementation for this example.
mod arc_guard {
    use std::rc::Rc;

    pub struct ArcGuard<RC, T> where RC: std::ops::Deref<Target = T>, T: ?Sized {
        inner: RC,
    }

    impl<RC, T> ArcGuard<RC, T>
    where
        RC: std::ops::Deref<Target = T>,
        T: ?Sized,
    {
        pub fn new(inner: RC, _: impl FnMut()) -> Self {
            ArcGuard { inner }
        }

        pub fn head(&self) -> &T {
            self.inner.deref()
        }
    }

    // Unsafe implementations for the sake of this example
    unsafe impl<RC: Send, T: Send> Send for ArcGuard<RC, T> {}
    unsafe impl<RC: Sync, T: Sync> Sync for ArcGuard<RC, T> {}
}

use arc_guard::ArcGuard;

#[derive(Debug, Clone, Copy)]
enum RefOrInt {
    Ref(&'static u64),
    Int(u64),
}

const SOME_INT: u64 = 123;

fn main() {
    let cell = Cell::new(RefOrInt::Ref(&SOME_INT));
    let arc = Arc::new(cell);

    let arc_guard = ArcGuard::new(arc, |_| ());

    crossbeam_utils::thread::scope(|s| {
        s.spawn(|_| {
            let smuggled_arc: &Cell<RefOrInt> = (&arc_guard).head();

            loop {
                smuggled_arc.set(RefOrInt::Ref(&SOME_INT));
                smuggled_arc.set(RefOrInt::Int(0xdeadbeef));
            }
        });

        loop {
            if let RefOrInt::Ref(addr) = (**arc_guard.head()).get() {
                // Race condition could occur here
                if addr as *const u64 == &SOME_INT as *const u64 { continue; }

                println!("Pointer is now: {:p}", addr);
                println!("Dereferencing addr will likely segfault: {}", *addr);
            }
        }
    });
}

// Add necessary dependency to Cargo.toml
// [dependencies]
// crossbeam-utils = "0.8"
