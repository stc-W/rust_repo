// src/main.rs
#![forbid(unsafe_code)]

// Proof that async-coap ≤ 6a7b592 is unsound.
// Builds with `cargo run --release` and soon seg-faults.

use async_coap::arc_guard::ArcGuard;
use crossbeam_utils::thread;
use std::{cell::Cell, sync::Arc};

#[derive(Debug, Clone, Copy)]
enum RefOrInt {
    Ref(&'static u64),
    Int(u64),
}

static SOME_INT: u64 = 123;

fn main() {
    // Cell<T> is !Send + !Sync, yet ArcGuard lets us move it across threads.
    let cell      = Cell::new(RefOrInt::Ref(&SOME_INT));
    let arc       = Arc::new(cell);
    let arc_guard = ArcGuard::new(arc, |_| ());

    // Ignore the Result from `scope` to avoid the “unused Result” warning.
    let _ = thread::scope(|s| {
        s.spawn(|_| {
            let smuggled_arc = arc_guard.head();
            loop {
                smuggled_arc.set(RefOrInt::Ref(&SOME_INT));
                smuggled_arc.set(RefOrInt::Int(0xdeadbeef));
            }
        });

        loop {
            if let RefOrInt::Ref(addr) = (**arc_guard.head()).get() {
                if addr as *const u64 == &SOME_INT as *const u64 {
                    continue;
                }
                println!("Pointer is now: {addr:p}");
                // Still “safe” syntax, but UB at runtime → SIGSEGV.
                println!("Dereferencing addr now segfaults: {}", *addr);
            }
        }
    });
}
