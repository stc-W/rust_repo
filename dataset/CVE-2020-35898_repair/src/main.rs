// Necessary imports and crate declarations
use std::cell::UnsafeCell;

/// Simulate the custom Cell implementation that does not track mutable references.
#[derive(Debug)]
struct CustomCell<T> {
    value: UnsafeCell<T>,
}

impl<T> CustomCell<T> {
    fn new(value: T) -> Self {
        CustomCell { value: UnsafeCell::new(value) }
    }

    // Obtain a mutable reference to the inner value without tracking
    unsafe fn get_mut(&self) -> &mut T {
        &mut *self.value.get()
    }
}

fn main() {
    let mycell = CustomCell::new(vec![1, 2, 3]);

    // Simulate obtaining multiple mutable references from `mycell`, leading to UB.
    let ref1 = unsafe { mycell.get_mut() };
    println!("ref1: {:?}", ref1);

    // Obtain a second mutable reference (this would lead to undefined behavior)
    let ref2 = unsafe { mycell.get_mut() };
    println!("ref2: {:?}", ref2);
    
    // Example of potentially unsound behavior
    ref2.push(4);  // This modifies the vector through one mutable reference
    ref1.pop();    // This could lead to UB if there is a race condition or unexpected state

    println!("Final mycell value after modifications: {:?}", unsafe { &*mycell.value.get() });
}
