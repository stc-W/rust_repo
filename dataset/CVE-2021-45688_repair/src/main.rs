//! Triggers issue #354 in ash::util::read_spv.
//!
//! On the buggy commit the first byte printed below is *usually* 0xAA (170) or
//! some other non-zero junk that leaked from the heap.  
//! After switching only the ash revision to 2c98b6f it is **always 0**.

use ash::util::read_spv;
use std::io::{self, Read, Seek, SeekFrom};

/// Reader that *peeks* at the provided buffer **before** copying data into it.
struct EvilReader {
    data: &'static [u8],
    pos:  usize,
}

impl Read for EvilReader {
    fn read(&mut self, buf: &mut [u8]) -> io::Result<usize> {
        // UB if `buf` is uninitialised – exactly the bug we want to show.
        println!("EvilReader saw first byte = {}", buf[0]);
        let remaining = &self.data[self.pos..];
        let n = remaining.len().min(buf.len());
        buf[..n].copy_from_slice(&remaining[..n]);
        self.pos += n;
        Ok(n)
    }
}

impl Seek for EvilReader {
    fn seek(&mut self, pos: SeekFrom) -> io::Result<u64> {
        self.pos = match pos {
            SeekFrom::Start(o)   => o as usize,
            SeekFrom::Current(o) => (self.pos as i64 + o) as usize,
            SeekFrom::End(o)     => (self.data.len() as i64 + o) as usize,
        };
        Ok(self.pos as u64)
    }
}

fn main() -> io::Result<()> {
    /* 1 ── Poison the allocator with blocks full of 0xAA so that an
     *       uninitialised Vec is likely to reuse one of them.             */
    for _ in 0..10_000 {
        let v = vec![0xAAu8; 4 * 256];
        std::hint::black_box(v);
    }

    /* 2 ── Minimal, valid SPIR-V module: 0x0723_0203 magic, version 1.0    */
    const SPV: [u8; 4] = 0x0723_0203u32.to_le_bytes();
    let mut reader = EvilReader { data: &SPV, pos: 0 };

    /* 3 ── Call the real library function that used to pass uninit memory. */
    let _words = read_spv(&mut reader)
        .map_err(|e| io::Error::new(io::ErrorKind::Other, e))?;

    Ok(())
}
