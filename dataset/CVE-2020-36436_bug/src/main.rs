// Cargo.toml dependencies:
// [dependencies]
// unicycle = "0.7.0"
// crossbeam-utils = "0.8"

#![forbid(unsafe_code)]

use std::cell::Cell;
use crossbeam_utils::thread;

extern crate unicycle; // Importing the `unicycle` crate

fn main() {
    let cell = Cell::new(ref_or_int_ref(&123));

    let mut slab = unicycle::pin_slab::PinSlab::new();
    slab.insert(&cell);

    thread::scope(|s| {
        s.spawn(move |_| {
            loop {
                let smuggled_cell = slab.get(0).unwrap();
                // Repeatedly write Ref(&addr) and Int(0xdeadbeef) into the cell.
                smuggled_cell.set(ref_or_int_ref(&123));
                smuggled_cell.set(ref_or_int_int(0xdeadbeef));
            }
        });

        loop {
            if let RefOrInt::Ref(addr) = cell.get() {
                // Hope that between the time we pattern match the object as a
                // `Ref`, it gets written to by the other thread.
                if addr as *const u64 == &123 as *const u64 { continue; }

                // Due to the data race, obtaining Ref(0xdeadbeef) is possible
                println!("Pointer is now: {:p}", addr);
                println!("Dereferencing addr will now segfault: {}", *addr);
            }
        }
    });
}

#[derive(Debug, Clone, Copy)]
enum RefOrInt { Ref(&'static u64), Int(u64) }

fn ref_or_int_ref(value: &'static u64) -> RefOrInt {
    RefOrInt::Ref(value)
}

fn ref_or_int_int(value: u64) -> RefOrInt {
    RefOrInt::Int(value)
}
