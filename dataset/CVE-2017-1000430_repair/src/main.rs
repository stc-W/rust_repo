// main.rs

use std::usize;
use base64::encoded_size;
#[derive(Debug)]
struct Config {
    line_wrap: LineWrap,
}

#[derive(Debug)]
enum LineWrap {
    NoWrap,
    Wrap(usize, LineEnding),
}

#[derive(Debug)]
enum LineEnding {
    CRLF,
    LF,
}

const STANDARD: Config = Config { line_wrap: LineWrap::NoWrap };

// fn encoded_size(bytes_len: usize, config: Config) -> Option<usize> {
//     let printing_output_chars = bytes_len
//         .checked_add(2)
//         .map(|x| x / 3)
//         .and_then(|x| x.checked_mul(4));

//     match config.line_wrap {
//         LineWrap::NoWrap => Some(0),
//         LineWrap::Wrap(n, ref line_ending) => match line_ending {
//             LineEnding::CRLF => printing_output_chars.map(|y| y / n).and_then(|y| y.checked_mul(2)),
//             LineEnding::LF => printing_output_chars.map(|y| y / n),
//         },
//     }
// }

fn main() {
    // This will trigger the integer overflow behavior
    match encoded_size(std::usize::MAX, STANDARD) {
        Some(n) => println!("Encoded size: {}", n),
        None => eprintln!("Integer overflow when calculating buffer size"),
    };
}
