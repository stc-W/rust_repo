// main.rs

#![forbid(unsafe_code)]

use metrics_util::AtomicBucket;
use std::cell::Cell;
use std::sync::Arc;

#[derive(Debug, Hash, PartialEq, Eq, Clone, Copy)]
enum RefOrInt {
    Ref(&'static u64),
    Int(u64),
}

// Define a static integer as in the original example
static SOME_INT: u64 = 123;

fn main() {
    // Create a Cell holding a reference to `SOME_INT`
    let cell = Cell::new(RefOrInt::Ref(&SOME_INT));

    // Initialize an AtomicBucket with the `cell` as its content
    let bucket = Arc::new(AtomicBucket::new());
    bucket.push(cell);

    // Create a clone of the bucket for the spawned thread
    let bucket_clone = bucket.clone();

    // Spawn another thread to concurrently modify the cell's contents
    std::thread::spawn(move || {
        let bucket = bucket_clone;

        // Continuously update the cell's content between `Ref(&SOME_INT)` and `Int(0xdeadbeef)`
        bucket.data_with(|arr| {
            for cell in arr.iter() {
                loop {
                    cell.set(RefOrInt::Ref(&SOME_INT));
                    cell.set(RefOrInt::Int(0xdeadbeef));
                }
            }
        });
    });

    // In the main thread, access and print the content of the cell
    bucket.data_with(|arr| {
        for cell in arr.iter() {
            loop {
                match cell.get() {
                    RefOrInt::Ref(addr) => {
                        if addr as *const u64 == &SOME_INT as *const u64 {
                            continue;
                        }
                        println!("Pointer is now {:p}", addr);
                        // Dereferencing `addr` here can cause undefined behavior
                        println!("Dereferencing addr will now segfault: {}", *addr);
                    },
                    _ => {}
                }
            }
        }
    });
}
