#![forbid(unsafe_code)]

use crossbeam_utils::thread;
use std::cell::Cell;

// This mock implementation of SyncChannel<T> is based on the assumption 
// that it should implement Send and Sync for types T where T: Send.
mod signal_simple {
    pub mod channel {
        use std::sync::{Arc, Mutex};

        #[derive(Debug)]
        pub struct SyncChannel<T> {
            queue: Arc<Mutex<Vec<T>>>,
        }

        impl<T> SyncChannel<T> {
            pub fn new() -> Self {
                SyncChannel { queue: Arc::new(Mutex::new(Vec::new())) }
            }

            pub fn send(&self, value: T) {
                self.queue.lock().unwrap().push(value);
            }

            pub fn recv(&self) -> Option<T> {
                let mut guard = self.queue.lock().unwrap();
                guard.pop()
            }
        }

        // This implementation assumes that SyncChannel should be bounded by T: Send.
        unsafe impl<T: Send> Send for SyncChannel<T> {}
        unsafe impl<T: Send> Sync for SyncChannel<T> {}
    }
}

use signal_simple::channel::SyncChannel;

// A simple tagged union used to demonstrate problems with data races in Cell.
#[derive(Debug, Clone, Copy)]
enum RefOrInt { Ref(&'static u64), Int(u64) }

fn main() {
    let cell = Cell::new(RefOrInt::Ref(&123));

    let channel = SyncChannel::new();
    // Send the reference to the cell across threads.
    channel.send(&cell);

    thread::scope(|s| {    
        s.spawn(|_| {
            let smuggled_cell = channel.recv().unwrap();
            loop {
                // Repeatedly write Ref(&addr) and Int(0xdeadbeef) into the cell.
                smuggled_cell.set(RefOrInt::Ref(&123));
                smuggled_cell.set(RefOrInt::Int(0xDEADBEEF));
            }
        });

        loop {
            if let RefOrInt::Ref(addr) = cell.get() {
                // Hope that between the time we pattern match the object as a
                // `Ref`, it gets written to by the other thread.
                if addr as *const u64 == &123 as *const u64 { continue; }

                println!("Pointer is now: {:p}", addr);
                println!("Dereferencing addr will now segfault: {}", *addr);
            }
        }
    });
}
