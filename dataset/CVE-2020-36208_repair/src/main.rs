use conquer_once::OnceCell;
use crossbeam_utils::thread;

use std::sync::Mutex;

fn main() {
    let once_cell = OnceCell::uninit();  
    thread::scope(|s| {
        s.spawn(|_| {
            once_cell.try_init_once(move || {
                let mutex_static = Box::leak(Box::new(Mutex::new(0_i32)));

                // `MutexGuard`is `Sync`, but not `Send`.
                let mutex_guard = mutex_static.lock().unwrap();
                let tid = std::thread::current().id();
                (mutex_guard, tid)
            }).unwrap();
        });
    }).unwrap();

    if let Some((smuggled_mutexguard, tid)) = once_cell.into_inner() {
        // `smuggled_mutexguard` is dropped at the end of its lexical scope.
        // The parent thread attempt to unlock the Mutex which it did not lock.
        // 
        // If a thread attempts to unlock a Mutex that it has not locked, it can result in undefined behavior.
        // (https://github.com/rust-lang/rust/issues/23465#issuecomment-82730326)
        assert_eq!(tid, std::thread::current().id());
    }
}