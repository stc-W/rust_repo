use std::{cell::Cell, sync::Arc, thread};
use reffers::aref::ARefss;

// Data we will race on
#[derive(Clone, Copy)]
enum RefOrInt<'a> { Ref(&'a u64), Int(u64) }

static X: u64 = 0;

fn main() {
    // smuggle a !Send + !Sync value through ARefss::map
    let outer = Arc::new(
        ARefss::new(Arc::new(0)).map(|_| Box::leak(Box::new(Cell::new(RefOrInt::Ref(&X)))))
    );
    let child = Arc::clone(&outer);

    // thread 1: flip between pointer and int
    thread::spawn(move || {
        let cell = child.as_ref();
        loop {
            cell.set(RefOrInt::Int(0xdeadbeef));
            cell.set(RefOrInt::Ref(&X));
        }
    });

    // thread 0: read until we observe the bogus pointer
    loop {
        if let RefOrInt::Ref(ptr) = outer.get() {
            if ptr as *const _ as usize == 0xdeadbeef {
                println!("got dangling ptr {:p}", ptr);
                println!("dereferencing = {}", unsafe { *ptr }); // segfault
            }
        }
    }
}
