#![forbid(unsafe_code)]

use std::sync::atomic::{AtomicUsize, Ordering};
static COUNT: AtomicUsize = AtomicUsize::new(0);

#[derive(Debug)]
struct Sentinel(bool);

impl Clone for Sentinel {
    fn clone(&self) -> Self {
        if self.0 {
            panic!();
        } else {
            Sentinel(self.0)
        }
    }
}

impl Drop for Sentinel {
    fn drop(&mut self) {
        COUNT.fetch_add(1, Ordering::SeqCst);
    }
}

#[derive(Debug)]
struct DropDetector(u32);

impl Drop for DropDetector {
    fn drop(&mut self) {
        println!("Dropping {}", self.0);
    }
}

impl Clone for DropDetector {
    fn clone(&self) -> Self { 
        panic!("Panic in clone()"); 
    }
}

fn main() {
    let input = [Sentinel(false), Sentinel(true)];

    // Mocking the StackA implementation to match the original problem scenario.
    struct StackA<T: ?Sized> {
        data: Vec<T>,
    }

    impl<T: Clone + ?Sized> StackA<[T]> {
        fn new() -> Self {
            StackA { data: vec![] }
        }

        // This is a simplified version of `push_cloned` which will trigger the issue.
        fn push_cloned(&mut self, v: &[T]) -> Result<(), String> {
            for val in v.iter() {
                let new_val = val.clone();  // This will panic if `val.0 == true`
                self.data.push(new_val);
            }
            Ok(())
        }

        // Mock pop function to simulate popping an element
        fn pop(&mut self) -> Option<T> {
            self.data.pop()
        }
    }

    let mut stack = StackA::new();
    
    match std::panic::catch_unwind(|| {
        stack.push_cloned(&input).unwrap_or_else(|err| panic!("Push error: {}", err));
    }) {
        Ok(_) => println!("No panic during push"),
        Err(_) => println!("Panic caught, checking COUNT..."),
    }

    // This will print the number of times the `Sentinel` was dropped.
    println!("COUNT: {}", COUNT.load(Ordering::SeqCst));

    let mut stack_dd = StackA::<[DropDetector]>::new();
    stack_dd.push_stable([DropDetector(1)], |p| p).unwrap();
    stack_dd.push_stable([DropDetector(2)], |p| p).unwrap();

    println!("Popping off second drop detector");
    let _second_drop = stack_dd.pop();

    println!("Pushing panicky-clone");
    match std::panic::catch_unwind(|| {
        stack_dd.push_cloned(&[DropDetector(3)]).unwrap_or_else(|err| panic!("Push error: {}", err));
    }) {
        Ok(_) => println!("No panic during push"),
        Err(_) => println!("Panic caught, checking drop sequence..."),
    }
}
