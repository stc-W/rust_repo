use futures::channel::oneshot;
use futures::task::{noop_waker, Context};
use futures::stream::once;
use actix_http::body::{MessageBody, BodyStream};
use bytes::Bytes;

fn main() {
    let (sender, receiver) = oneshot::channel();
    let mut body_stream = Ok(BodyStream::new(once(async move {
        // This box and reference is used to simulate the unsafe pinning issue.
        let x = Box::new(0);
        let y = &x;
        receiver.await.unwrap();  // Wait for sender to send something
        let _z = **y;  // Dereference y, which should be safe if correctly pinned
        Ok::<_, ()>(Bytes::new())
    })));

    let waker = noop_waker();
    let mut context = Context::from_waker(&waker);

    // This call to poll_next is part of the bug triggering logic.
    let _ = body_stream.as_mut().unwrap().poll_next(&mut context);
    
    sender.send(()).unwrap();  // Signal receiver to proceed
    
    // Another call to poll_next after replacing `body_stream` with an error.
    let _ = std::mem::replace(&mut body_stream, Err([0; 32])).unwrap().poll_next(&mut context);
}
