#![forbid(unsafe_code)]

use arr::Array;
use std::sync::{Arc, Mutex};
use std::thread;

// Mocked implementation of Array to reproduce the bug without needing the actual crate
mod arr {
    use std::clone::Clone;
    
    pub struct Array<T> {
        data: Vec<T>,
    }

    impl<T> Array<T> {
        // Mimicking the behavior that allows non-Send/Sync types across thread boundaries
        pub fn new_from_template(size: usize, template: &T) -> Array<T>
        where
            T: Clone,
        {
            let mut data = Vec::with_capacity(size);
            for _ in 0..size {
                data.push(template.clone());
            }
            Array { data }
        }

        // Mimicking the lack of bounds checking for Index implementation
        pub fn get(&self, index: usize) -> &T {
            &self.data[index]
        }
    }

    impl<T> std::ops::Index<usize> for Array<T> {
        type Output = T;
        
        fn index(&self, idx: usize) -> &Self::Output {
            self.get(idx)
        }
    }

    // Implementing Sync and Send to simulate the issue
    unsafe impl<T: Sync> Sync for Array<T> {}
    unsafe impl<T: Send> Send for Array<T> {}
}

fn main() {
    // 1. Incorrect Sync/Send bounds for `Array` allows to smuggle non-Sync/Send types across thread boundary
    let rc = Arc::new(Mutex::new(0usize));
    let arr = Array::new_from_template(1, &rc);
    
    let arr_handle = &arr;
    
    // Cloning an Rc in a different thread (should not be allowed)
    println!("Cloning Arc in a different thread");
    thread::spawn(move || {
        let another_rc: Arc<Mutex<usize>> = arr_handle[0].clone();
        println!("Clone succeeded, value: {:?}", *another_rc.lock().unwrap());
    }).join().expect("Thread failed to join");

    // 2. `Index` and `IndexMut` does not check the bound
    let arr = Array::new_from_template(1, &0usize);
    println!("OOB read: {}", arr[10]);
}
