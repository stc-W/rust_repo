use va_ts::{Demuxer, DemuxerEvents, SubtableID, DemuxedPacket, DemuxedTable};
use std::sync::{Mutex, MutexGuard};
use std::thread::{self, ThreadId};
use std::ops::Drop;

struct X(MutexGuard<'static, u64>, ThreadId);
impl DemuxerEvents for X {
    fn on_table(&mut self, _: SubtableID, _: &DemuxedTable) { }
    fn on_packet(&mut self, _: &DemuxedPacket) { }
}
impl Drop for X {
    fn drop(&mut self) {
        // `MutexGuard` must not be dropped from a thread that didn't lock the `Mutex`.
        //
        // If a thread attempts to unlock a Mutex that it has not locked, it can result in undefined behavior.
        // (https://github.com/rust-lang/rust/issues/23465#issuecomment-82730326)
        assert_eq!(self.1, thread::current().id());
    }
}

fn main() {
    let static_mutex = Box::leak(Box::new(Mutex::new(0xbeefbeef_u64)));
    // MutexGuard is `!Send`
    let mutex_guard = static_mutex.lock().unwrap();
    let tid = thread::current().id();

    let demuxer = Demuxer::new(X(mutex_guard, tid));
    std::thread::spawn(move || {
        let demuxer = demuxer;

        // demuxer is dropped here, along with `MutexGuard`.
    }).join().unwrap();
}