use std::boxed::Box;
use std::mem;

// Mocked definitions to simulate StreamUserData, StreamCallbackResult, and stream callback behavior.
struct StreamUserData<I, O> {
    callback: Option<Box<dyn FnMut(&[I], &mut [O]) -> StreamCallbackResult>>,
}

enum StreamCallbackResult {
    Continue,
    Abort,
}

impl<I, O> Drop for StreamUserData<I, O> {
    fn drop(&mut self) {
        println!("StreamUserData is being dropped!");
    }
}

fn unsafe_callback(user_data: *mut std::ffi::c_void) -> StreamCallbackResult {
    let mut stream_data: Box<StreamUserData<i32, i32>> = unsafe { mem::transmute(user_data) };
    
    // Simulate a panic to demonstrate the bug
    if let Some(ref mut f) = stream_data.callback {
        (*f)(vec![1].as_slice(), &mut [0]);
    } else {
        StreamCallbackResult::Abort
    }
}

fn main() {
    // Mocked user data with a closure that may panic.
    let mut stream_data: Box<StreamUserData<i32, i32>> = Box::new(StreamUserData {
        callback: Some(Box::new(|input, output| {
            if input[0] == 1 {
                panic!("Panic in the callback!");
            }
            StreamCallbackResult::Continue
        })),
    });

    // Simulate calling the unsafe_callback function.
    let user_data_ptr = Box::into_raw(stream_data);
    
    // This will trigger a panic and should show that `StreamUserData` was not dropped properly.
    match std::panic::catch_unwind(|| {
        unsafe_callback(user_data_ptr as *mut _)
    }) {
        Ok(_) => println!("Callback did not panic."),
        Err(_) => println!("Callback panicked!"),
    }

    // Manually drop the data to show it wasn't forgotten due to a panic.
    let stream_data = unsafe { Box::from_raw(user_data_ptr) };
    mem::forget(stream_data);
}
